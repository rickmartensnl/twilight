<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="twilight-standby"><title>twilight_standby - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twilight_standby" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (0c81f94b9 2024-07-10)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twilight_standby/index.html">twilight_standby</a><span class="version">0.16.0-rc.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">twilight_standby</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/twilight_standby/lib.rs.html#1-1584">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="twilight-standby"><a class="doc-anchor" href="#twilight-standby">§</a>twilight-standby</h2>
<p><a href="https://app.codecov.io/gh/twilight-rs/twilight/"><img src="https://img.shields.io/codecov/c/gh/twilight-rs/twilight?logo=codecov&amp;style=for-the-badge&amp;token=E9ERLJL0L2" alt="codecov badge" /></a> <a href="https://discord.gg/7jj8n7D"><img src="https://img.shields.io/discord/745809834183753828?color=%237289DA&amp;label=discord%20server&amp;logo=discord&amp;style=for-the-badge" alt="discord badge" /></a> <a href="https://github.com/twilight-rs/twilight"><img src="https://img.shields.io/badge/github-twilight-6f42c1.svg?style=for-the-badge&amp;logo=github" alt="github badge" /></a> <a href="https://github.com/twilight-rs/twilight/blob/main/LICENSE.md"><img src="https://img.shields.io/badge/license-ISC-blue.svg?style=for-the-badge&amp;logo=pastebin" alt="license badge" /></a> <img src="https://img.shields.io/badge/rust-1.67+-93450a.svg?style=for-the-badge&amp;logo=rust" alt="rust badge" /></p>
<p>Standby is a utility to wait for an event to happen based on a predicate
check. For example, you may have a command that has a reaction menu of ✅
and ❌. If you want to handle a reaction to these, using something like an
application-level state or event stream may not suit your use case. It may
be cleaner to wait for a reaction inline to your function. This is where
Twilight Standby comes in.</p>
<p>Standby allows you to wait for things like an event in a certain guild
(<a href="struct.Standby.html#method.wait_for" title="method twilight_standby::Standby::wait_for"><code>Standby::wait_for</code></a>), a new message in a channel
(<a href="struct.Standby.html#method.wait_for_message" title="method twilight_standby::Standby::wait_for_message"><code>Standby::wait_for_message</code></a>), a new reaction on a message
(<a href="struct.Standby.html#method.wait_for_reaction" title="method twilight_standby::Standby::wait_for_reaction"><code>Standby::wait_for_reaction</code></a>), and any event that might not take place in
a guild, such as a new <code>Ready</code> event (<a href="struct.Standby.html#method.wait_for_event" title="method twilight_standby::Standby::wait_for_event"><code>Standby::wait_for_event</code></a>). Each
method also has a stream variant.</p>
<p>To use Standby it must process events, such as in an event loop of events
received by the gateway. Check out the <a href="struct.Standby.html#method.process" title="method twilight_standby::Standby::process"><code>Standby::process</code></a> method.</p>
<h3 id="when-to-use-futures-and-streams"><a class="doc-anchor" href="#when-to-use-futures-and-streams">§</a>When to use futures and streams</h3>
<p><a href="struct.Standby.html" title="struct twilight_standby::Standby"><code>Standby</code></a> has two variants of each method: a future variant and a stream
variant. An example is <a href="struct.Standby.html#method.wait_for_message" title="method twilight_standby::Standby::wait_for_message"><code>Standby::wait_for_message</code></a>, which also has a
<a href="struct.Standby.html#method.wait_for_message_stream" title="method twilight_standby::Standby::wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a> variant. The future variant is useful
when you want to oneshot an event that you need to wait for. This means that
if you only need to wait for one message in a channel to come in, you’d use
the future variant. If you need to wait for multiple messages, such as maybe
all of the messages within a minute’s timespan, you’d use the
<a href="struct.Standby.html#method.wait_for_message_stream" title="method twilight_standby::Standby::wait_for_message_stream"><code>Standby::wait_for_message_stream</code></a> method.</p>
<p>The difference is that if you use the futures variant in a loop then you may
miss some events while processing a received event. By using a stream, you
won’t miss any events.</p>
<h3 id="timeouts"><a class="doc-anchor" href="#timeouts">§</a>Timeouts</h3>
<p>Timeouts on futures isn’t directly provided by Standby. Futures can be timed out
with support from crates such as <a href="https://docs.rs/tokio/latest/tokio/time/fn.timeout.html"><code>tokio::time::timeout</code></a>. An example of this is
detailed on the <a href="struct.Standby.html" title="struct twilight_standby::Standby"><code>Standby</code></a> type.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3><h4 id="at-a-glance"><a class="doc-anchor" href="#at-a-glance">§</a>At a glance</h4>
<p>Wait for a message in channel 123 by user 456 with the content “test”:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>twilight_model::{
    gateway::payload::incoming::MessageCreate,
    id::Id,
};
<span class="kw">use </span>twilight_standby::Standby;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
    <span class="kw">let </span>standby = Standby::new();

    <span class="kw">let </span>channel_id = Id::new(<span class="number">123</span>);

    <span class="kw">let </span>message = standby.wait_for_message(channel_id, |event: <span class="kw-2">&amp;</span>MessageCreate| {
        event.author.id.get() == <span class="number">456 </span>&amp;&amp; event.content == <span class="string">"test"
    </span>}).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h4 id="a-full-example"><a class="doc-anchor" href="#a-full-example">§</a>A full example</h4>
<p>A full sample bot connecting to the gateway, processing events, and
including a handler to wait for reactions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{env, sync::Arc};
<span class="kw">use </span>twilight_gateway::{Event, EventTypeFlags, Intents, Shard, ShardId, StreamExt <span class="kw">as _</span>};
<span class="kw">use </span>twilight_model::{
    channel::Message,
    gateway::payload::incoming::ReactionAdd,
};
<span class="kw">use </span>twilight_standby::Standby;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; anyhow::Result&lt;()&gt; {
    <span class="kw">let </span>token = env::var(<span class="string">"DISCORD_TOKEN"</span>)<span class="question-mark">?</span>;

    <span class="comment">// Start a shard connected to the gateway to receive events.
    </span><span class="kw">let </span>intents = Intents::GUILD_MESSAGES | Intents::GUILD_MESSAGE_REACTIONS;
    <span class="kw">let </span><span class="kw-2">mut </span>shard = Shard::new(ShardId::ONE, token, intents);

    <span class="kw">let </span>standby = Arc::new(Standby::new());

    <span class="kw">while let </span><span class="prelude-val">Some</span>(item) = shard.next_event(EventTypeFlags::all()).<span class="kw">await </span>{
        <span class="kw">let </span><span class="prelude-val">Ok</span>(event) = item <span class="kw">else </span>{
            <span class="macro">tracing::warn!</span>(source = <span class="question-mark">?</span>item.unwrap_err(), <span class="string">"error receiving event"</span>);

            <span class="kw">continue</span>;
        };

        <span class="comment">// Have standby process the event, which will fulfill any futures
        // that are waiting for an event.
        </span>standby.process(<span class="kw-2">&amp;</span>event);

        <span class="kw">match </span>event {
            Event::MessageCreate(msg) <span class="kw">if </span>msg.content == <span class="string">"!react" </span>=&gt; {
                tokio::spawn(react(msg.<span class="number">0</span>, Arc::clone(<span class="kw-2">&amp;</span>standby)));
            },
            <span class="kw">_ </span>=&gt; {},
        }
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="comment">// Wait for a reaction from the user who sent the message, and then print it
// once they react.
</span><span class="kw">async fn </span>react(msg: Message, standby: Arc&lt;Standby&gt;) -&gt; anyhow::Result&lt;()&gt; {
    <span class="kw">let </span>author_id = msg.author.id;

    <span class="kw">let </span>reaction = standby.wait_for_reaction(msg.id, <span class="kw">move </span>|event: <span class="kw-2">&amp;</span>ReactionAdd| {
        event.user_id == author_id
    }).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">"user reacted with {:?}"</span>, reaction.emoji);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>For more examples, check out each of the methods on <a href="struct.Standby.html" title="struct twilight_standby::Standby"><code>Standby</code></a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="future/index.html" title="mod twilight_standby::future">future</a></div><div class="desc docblock-short">Futures and streams returned by <a href="struct.Standby.html" title="struct twilight_standby::Standby"><code>Standby</code></a>.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ProcessResults.html" title="struct twilight_standby::ProcessResults">ProcessResults</a></div><div class="desc docblock-short">Number of <a href="struct.Standby.html" title="struct twilight_standby::Standby"><code>Standby</code></a> calls that were completed.</div></li><li><div class="item-name"><a class="struct" href="struct.Standby.html" title="struct twilight_standby::Standby">Standby</a></div><div class="desc docblock-short">The <code>Standby</code> struct, used by the main event loop to process events and by
tasks to wait for an event.</div></li></ul></section></div></main></body></html>